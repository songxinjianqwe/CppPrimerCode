/*
 * 578FunctionTemplace.cpp
 *
 *  Created on: 2016年9月27日
 *      Author: songx
 */

#include <cstring>
#include <iostream>

using namespace std;

//一个模板就是一个创建类或函数的蓝图
//定义一个通用的函数模板，一个函数模板就是一个公式，可用来生成针对特定类型的函数版本
//模板定义以关键字template开始，后跟一个模板参数列表，是一个逗号分隔的一个或多个模板参数的列表
//模板参数列表不可为空
//模板参数列表类似于函数参数列表，定义了若干类型的局部变量
//模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们隐式或显式地指定模板实参，将其绑定到模板参数上。

//实例化参数模板
//当我们定义一个函数模板时，编译器通常用函数实参来为我们推断模板实参。
//编译器使用推断出的模板参数来为我们实例化一个特定版本的函数。
//当编译器实例化一个模板时，它使用实际的模板实参来代替对应的模板参数来创建出模板的一个实例。

template<typename T>
int compare(const T & v1, const T& v2) {
	if (v1 < v2) {
		return -1;
	} else if (v1 > v2) {
		return 1;
	} else {
		return 0;
	}
}
void test1() {
	cout << compare(1, 0) << endl;
}
//在编译器会生成一个compare版本
int compare(const int & v1, const int & v2) {
	if (v1 < v2) {
		return -1;
	} else if (v1 > v2) {
		return 1;
	} else {
		return 0;
	}
}
//这些编译器生成的版本被称为模板的实参

//模板类型参数
//compare函数有一个模板类型参数（type parameter）
//类型参数可以用来指定返回类型或参数的参数类型，以及在函数体内用于变量声明或类型转换
template<typename T>
T foo(T * p) {
	T temp = *p;
	//...
	return temp;
}
//类型参数之前必须加上typename或class关键字
//这两个关键字的含义相同，可以互换使用

//除了定义类型参数，还可以在模式中定义非类型参数
//一个非类型参数表示一个值而非一个类型
//我们通过一个特定的类型名而非class/typename来指定非类型参数
//当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。
//这些值必须是常量表达式，从而允许编译器在编译时实例化模板

//我们可以编写一个compare版本处理字符串字面量，const char数组
//要传入一个数组，将参数定义为数组的引用。由于我们希望能比较不同长度的字符串字面量，因此为模板定义了两个非类型参数
//第一个模板参数表示一个第一个数组的长度，第二个参数表示第二个数组的长度
template <unsigned N,unsigned M>
int compare(const char (&p1)[N],const char(&p2)[M]){
	return strcmp(p1,p2);
}
void test2(){
	cout<<compare("hi","haha")<<endl;
}

//当调用这个版本的compare时
//编译器会使用字面量的大小来代替N和M，从而实例化模板。
//编译器会在一个字符串字面量的末尾插入一个空字符作为终结符
//因此，编译器会实例化如下版本：
//int compare(const char (&p1)[3],const char(&p2)[5]){

//一个非类型参数可以是一个整型，或者是一个指向对象或函数的指针或引用。绑定到非类型参数的实参必须是一个常量表达式。
//绑定到指针或引用非类型参数的实参必须具有静态的生存期（静态变量/全局变量）
//指针参数也可以用nullptr或一个值为0的常量表达式来实例化。
//模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用非类型参数，如制定数组大小。


//函数模板可以声明为inline或constexpr的，如果非模板函数一样，inline或constexpr说明符放在模板参数列表之后，返回类型之前
//template <typename T> 
//inline T min(const T&,const &);

//编写泛型代码的两个重要原则：
//模板中的函数参数是const引用
//函数体中的函数判断仅使用<运算符

//好处是函数可以用于不能拷贝的类型
//当然，这仍然要求参数实现<运算符
//如果真的要求类型无关，需要使用less函数对象
template <typename T>
int compare2(const T & v1,const T & v2){
	if(less<T>()(v1,v2)){
		return -1;
	}else if(less<T>()(v2,v1)){
		return 1;
	}else{
		return 0;
	}
}
//模板程序应该尽量减少对实参类型的要求

//模板编译
//当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码
//当我们使用模板时，编译器才生成代码。


//!!!!!!!!!文件组织!!!!!!!!!!!!!!!!!!!!
//当我们调用一个函数时，编译器只需要掌握函数的声明。当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必出现。
//因此，我们将类定义和函数声明放到头文件中，普通函数和类的成员函数的定义放在源文件中。
//模板与之不同
//为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，模板的头文件通常既包括声明又包括定义
//模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。
//模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件

//大多数错误在实例化期间报告，只有这个阶段才能发现类型相关的错误。这类错误可能在链接时才报告
//当我们编写模板时，代码不能是针对特定类型的，但模板代码通常对其所使用的类型有一些假设。
//保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正常工作，是调用者的责任。

