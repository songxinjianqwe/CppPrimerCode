/*
 * 599Effiency&Flexibility.cpp
 *
 *  Created on: 2016年9月29日
 *      Author: songx
 */




#include <iostream>
using namespace std;


//效率与灵活性
//shared_ptr和unique_ptr之间的明显不同是它们管理所保存的指针的策略-------前者给予我们共享指针所有权的能力，后者则独占指针。
//另一个差异是它们允许用户重载默认删除器的方式。我们可以重载一个shared_ptr的删除器，只要在创建或resize指针时传递给它一个可调用对象即可。
//与之相反，删除器的类型是一个unique_ptr对象的类型的一部分。用户必须在定义unique_ptr时以显式模板实参的形式提供删除器的类型。
//因此，对于unique_ptr的用户，提供自己的删除器就更为复杂。

//如何处理删除器的差异实际上就是这两个类的差异.

//shared_ptr必须能直接访问其删除器,级删除器必须保存为一个指针或一个封装了指针的类
//我们可以确定shared_ptr不是将删除器直接保存为一个成员，因为删除器的类型直到运行时才会知道。
//通常，类成员的类型在运行时是不能改变的。因此，不能直接保存删除器。

//让我们假定shared_ptr将它管理的指针保存在一个成员p中，且删除器是通过一个名为del的成员来访问的。
//因此shared_ptr的析构函数必须有：
//del ? del(p) :delete p; //del(p)需要运行时跳转到del的地址
//由于删除器是间接保存的，调用del(p)需要一次运行时的跳转操作，转到del中保存的地址来执行对应的代码。

//*************************************************************************************************

//在编译时绑定删除器
//unique_ptr类中删除器的类型是类类型的一部分。
//unique_ptr有两个模板参数，一个表示它管理的指针，另一个表示删除器的类型
//由于删除器的类型是unique_ptr类型的一部分，所以删除器成员的类型在编译时是知道的，从而删除器可以直接保存在unique_ptr对象中。
//通过在编译时绑定山粗气，unique_ptr避免了间接调用删除器的运行时开销；通过在运行时绑定删除器，shared_ptr使用户重载删除器更方便。









