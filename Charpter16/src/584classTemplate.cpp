/*
 * 584classTemplate.cpp
 *
 *  Created on: 2016年9月27日
 *      Author: songx
 */

#include "../header/Blob.h"


using namespace std;

//类模板是用来使用类的蓝图的
//与函数模板的区别是编译器不能为类模板推断模板参数类型
//我们必须在模板名之后的尖括号中提供额外信息，用来代替模板参数的模板实参列表

//定义类模板
//StrBlob-->Blob，不只是支持stirng
//当使用Blob时，用户需要指明函数类型
//类模板以关键字template开始，后跟模板参数列表。在类模板的定义中，我们将模板参数当做替身，代替使用模板时用户需要提供的类型偶值

//实例化类模板
//当使用一个类模板时，我们必须提供额外信息，即显式模板实参列表，它们被绑定到模板参数。
//编译器使用这些模板实参来实例化出特定的类
void test8(){
	Blob<string> sBlob;
}
//当编译器从我们的Blob模板实例化出一个类时，它会重写Blob模板，将模板参数T的每个实例替换为给定的模板实参 ，在这里是int
//一个类模板的每个实例都形成一个独立的类。
//类型Blob<string>与任何其他Blob类型都没有关联，也不会对任何其他Blob类型的成员有特殊的访问权限。

//在模板（作用域）中引用模板类型
//一个类模板中的代码如果使用了另一个模板，通常不将一个实际类型或值的名字作为其模板实参，而是将模板自己的参数当做被使用模板的实参
//例如shared_ptr<T>(vector<T>> data;

//类模板的成员函数
//我们既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。
//类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。
//因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表

//当我们在类外定义一个成员时，需要说明所属类。而且，从一个模板生成的类的名字中必须包含其模板实参。类似于className<T>::
//当我们定义一个成员函数时，模板实参与模板形参相同
//对于这样一个函数 retType StrBlob::memberName(params)
//声明为
//template<typename T>
//retType StrBlob<T>::memberName(params)

//*******************************************************************************

//类模板成员函数的实例化
//一个类模板的成员函数只有当程序用到它的时候才进行实例化
//如果一个成员函数没有被使用，则它不会被初始化。成员函数只有在被用到时才进行实例化，这一特性使得即使某种类型不能完全符合
//模板操作的要求，我们仍能使用该类型实例化类
//默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化
//******************************************************************************
//在类代码内简化模板类型的使用
//当我们使用一个类模板类型时必须提供模板实参。但是在类模板自己的作用域中，我们可以直接使用模板名而不提供实参。
//比如在BlobPtr模板类中
//BlobPtr & operator++();
//这里应该返回BlobPtr<T> ，但是省略了类型实参<T>
//当我们处于一个类模板的作用域中时，编译器处理模板自身引用时就好像我们已经提供了与模板参数匹配的实参一样。

//********************************************************************************
//在类模板外使用类模板名
//当我们在类模板外定义其成员时，我们并不在类的作用域中，直至遇到类名才表示进入了类的作用域

/*
template<typename T>
BlobPtr<T> & BlobPtr<T>::operator++(int){
	BlobPtr ret = *this;
	++*this;
	return ret;
}
*/
//由于返回类型在类的作用域之外，我们必须指出返回类型是一个实例化的BlobPtr。在函数体内，我们已经进入类的作用域，
//因此在定义ret的时候无序重复模板实参。

//在一个类模板的作用域之内，我们可以直接使用模板名而不必指定模板实参。


//******************************************************************************************
//类模板与友元

//当一个类包含一个友元声明时，类和友元各自是否是模板是相互无关的。
//如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。
//如果友元自身是模板，那么类可以授权给所有友元模板实例，也可以只授权给特定实例。

//一对一友好关系
//类模板与另一个模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。
//如：将Blob与BlobPtr（都为类模板，且类型参数一致）定义为友元
//如：将Blob（类模板）和一个相等运算符（模板函数，且类型参数一致） 定义为友元
//声明一个类模板：template<typename> class className;
//声明一个函数模板：template<typename T> retType functionName(params);

//(相同模板参数)函数模板的友元声明:
//friend retType functionName<T>(params);

//(相同模板参数)类模板的友元声明:
//friend class className<T>;

//(不同模板参数)类模板的友元声明:
//template<typename T> friend class className<T>;


//如果友元类和当前类的类型参数一致，那么只有当实例的参数类型相同时，这两个类才有友元关系。

//**************************************************************************
//除了类型参数一致的情况，一个类（或类模板）也可以将一个类模板的每个实例都声明为自己的友元，或者限定特定的实例为自己的友元

template <typename T> class Pal;


class C{//普通类
	friend class Pal<C>;//用类C实例化的Pal是C的一个友元
	template <typename T> friend class Pal2;//Pal2的所有实例都是C的友元，这种情况无需前置声明
};

//

template <typename T>class C2{//类模板
	friend class Pal<T>;//C2的每个实例将相同实例化的Pal声明为友元
	template <typename X> friend class Pal2;//Pal2类的每个实例都是C2的每个实例的友元，不需要前置声明
	friend class Pal3;//不需要Pal3的前置声明
};
//为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数
//总结：如果友元类(函数)的类型参数与当前类不同（或者当前类不是模板），都不需要声明；相同的时候要声明


//**************************************************************************************
//令模板自己的类型参数成为友元
template <typename Type> class Bar{
	friend Type;//将访问权限授予用来实例化Bar的类型
};

//此时我们将用来实例化Bar的类型声明为友元。因此，对于某个类型名Foo，Foo将成为Bar<Foo>的友元。
//虽然友元通常来说应该是一个类或一个函数，但是我们可以用一个内置类型来实例化Bar。这种与内置类型的友关系是允许的。

//*******************************************************************************************
//模板类型别名
//由于模板不是一个类型，我们不能定义一个typedef 引用Blob<T>
//但是，我们可以额为类模板定义一个类型别名
template<typename T> using twin = pair<T,T>;
twin<string>authors;

//一个模板类型别名是一族类的别名
twin<int> win_lose;

//当我们定义模板类型别名时，可以固定一个或多个模板参数
template<typename T> using partNo = pair<T,unsigned>;
partNo<string>books;//books是一个pair<string,unsigned>

//*********************************************************************************************

//类模板的static成员
template<typename T>class Foo{
public:
	static size_t count(){
		return ctr;
	}
private:
	static size_t ctr;
};
//每个Foo的实例都有其自己的static成员实例。
//对于任意给定类型X,都有一个Foo<X>::ctr和一个Foo<X>::count成员
//所有Foo<X>类型的对象共享相同的ctr对象和count函数
Foo<int> f1,f2,f3;//三个对象共享相同的Foo<int>::ctr Foo<int>::count

//类模板的每个实例都有一个独有的static对象
//因此，与定义模板的成员函数类似，我们将static数据成员也定义为模板
template<typename T>
size_t Foo<T>::ctr = 0;
//定义的开始是模板参数列表，随后是我们定义的成员的类型和名字。
//成员名包括成员的类名，包括类型参数
//为了通过类来直接访问static成员，我们必须引用一个特定的实例 如<int>
void test10(){
	Foo<int> f1;
	auto ct = Foo<int>::count();
	ct = f1.count();
//	ct = Foo::count();//error
} 


