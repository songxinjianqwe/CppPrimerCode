/*
 * 473movefunctionoperator.cpp
 *
 *  Created on: 2016年9月14日
 *      Author: songx
 */


#include <iostream>
using namespace std;

//标准库具有移动构造函数和移动赋值运算符
//为了让我们自己的类型支持移动操作，需要为它们定义移动构造函数和移动赋值运算符
//它们能从给定对象窃取资源而不是拷贝资源

//移动构造函数的第一次参数是该类类型的一个右值引用，任何额外的参数都必须有默认实参。
//除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一种状态：销毁它是无害的。
//一旦资源完成移动，源对象必须不再指向被移动的资源----这些资源的所有权已经归属新创建的对象

StrVec::StrVec(StrVec && vec) noexcept :elements(vec.elements),firstFree(vec.firstFree),cap(vec.cap)  {
	vec.elements = vec.cap = vec.firstFree = nullptr;
}

//注意 noexcept在声明时就需要加上，作用是通知标准库我们的构造函数不抛出任何异常
//移动构造函数不分配任何新内存：它接管给定的StrVec中的内存。在接管内存之后，它将给定对象中的指针都置为nullptr，此对象将继续存在。
//最终，移后源对象将被销毁，意味着将在其上运行析构函数
//如果我们忘记置为nullptr，则销毁以后源对象就会释放掉我们刚刚移动的内存。

//移动操作窃取资源而不是分配资源，因此移动操作通常不会抛出任何异常。当编写一个不抛出异常的移动操作时，我们应该讲此事通知标准库。
//除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。
//一种通知标准库的方法是在我们的构造函数中指明noexcept，noexcept是我们承诺一个函数不抛出异常的一种方法。我们在一个函数的参数列表后制定noexcept。
//在一个构造函数中，noexcept出现在参数列表和初始化列表开始的冒号之间。


//不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept
//原因：
//除非编译器知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。
//如果希望移动而不是拷贝，必须显式告诉标准库我们的移动构造函数可以安全使用。我们通过将移动构造函数标记为noexcept来做到这一点。

//移动赋值运算符
//移动赋值运算符执行与析构函数和移动构造函数相同的工作。同样应该标记为noexcept
//需要处理自赋值的问题

StrVec&StrVec::operator=(StrVec && vec)noexcept{
	if(&vec != this){
		free();
		elements = vec.elements;
		firstFree = vec.firstFree;
		cap = vec.cap;
		vec.elements = vec.firstFree = vec.cap = nullptr;
	}
	return *this;
}


//检查自赋值的原因：
//移动赋值运算符需要右侧运算对象的一个右值引用，此右值引用可能是move调用返回的结果。
//与其他任何赋值运算符一样，我们不能在使用右侧运算对象资源之前就释放左侧运算对象的资源。


//移后源对象必须可以析构
//从一个对象移动数据并不会小孩此对象，但有时在移动操作完成后，源对象会被销毁。
//因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。这是通过将移后源对象的指针成员置为nullptr实现的。
//除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的。
//一般来说，对象有效就是可以安全地为其赋予新值，可安全地使用而不依赖其当前值。移动操作应该对象移后源对象留下的值没有任何操作。

//总之，移后源对象必须保持有效的、可析构的状态，但是不能对其值有任何假设。

//编译器也会合成移动构造函数和移动赋值运算符，但是合成移动操作的条件与合成拷贝操作的条件大不相同。
//编译器根本不会为某些类合成移动操作。特别是当一个类定义了自己的拷贝构造函数、拷贝赋值运算符、析构函数，编译就不会为它合成移动构造函数和移动赋值运算符了。
//因此某些类就没有移动构造函数或移动赋值运算符。
//如果一个类米有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作。
//只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非静态成员都可以移动，编译器才会为它合成移动构造函数或移动赋值运算符。
//编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员

class X{
	int i;
	string s;//内置类型可以移动（可以作为move函数的参数）
};
class HasX{
	X mem;//X有合成的移动操作
};
void test40(){
	X x,x2 = std::move(x);//使用合成移动构造函数
	HasX hx,hx2 = std::move(hx);//使用合成移动构造函数
}
//与考别操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显式地要求编译器生成=default的移动操作，且编译器不能移动所有成员，此时编译器会将移动操作定义为删除函数
//以下情况移动构造函数被定义为删除的：
//1.编译器不能为成员变量合成移动构造函数(比如定义了拷贝而没定义移动)
//2.成员变量的移动构造函数或移动赋值运算符被定义为删除的或不可访问的
//3.析构函数被定义为删除的或不可访问的
//4.成员变量是const的或是引用类型

//移动操作和合成的拷贝控制成员还有一个关系：如果类定义了移动构造函数和/或移动赋值运算符，那么类的合成拷贝构造函数和拷贝赋值运算符就被定义为删除的
//因此，定义了移动操作也必须同时定义拷贝操作

//使用拷贝构造函数or移动构造函数是根据函数匹配的结果的
//拷贝构造函数接受一个const左值引用，移动构造函数接受一个右值引用
//因此，参数是左值引用就调用拷贝构造函数，是右值引用就调用移动构造函数

//如果没有移动构造函数，那么右值引用也会被匹配掉拷贝构造函数，此时右值引用会转为const左值引用。
//用拷贝构造函数代替移动构造函数一定是安全的。

//拷贝赋值运算符和移动赋值运算符可以合二为一，合并为一个赋值运算符(采用拷贝并交换的方式)

StrVec & StrVec::operator=(StrVec vec){
	swap(*this,vec);
	return *this;
}

//这个运算符有一个非引用参数，意味着参数要进行拷贝初始化：要么使用拷贝构造函数，要么使用移动构造函数------左值被拷贝，右值被移动
//因此，单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种操作

//注意！移动操作一定会先调用move()得到右值引用
//所有五个拷贝控制成员应该看做一个整体，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。






