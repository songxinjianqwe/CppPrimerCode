/*
 * 449default.cpp
 *
 *  Created on: 2016年9月12日
 *      Author: songx
 */
#include <iostream>
using namespace std;

//使用default
//将拷贝控制成员定义为default来显式地要求编译器生成合成的版本
//当我们在类内用=default修饰成员的声明，合成的函数将隐式地声明为内联的。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default
class SaleData{
public:
	SaleData() = default;
	SaleData(const SaleData &) = default;
	SaleData & operator=(const SaleData &);
	~SaleData() = default;
};
SaleData & SaleData::operator =(const SaleData & sd) = default;
//我们只能对具有合成版本的成员函数使用=default ，如默认构造函数或拷贝控制成员

//阻止拷贝
//对某些类而言，拷贝没有意思，并且定义类时必须采用某种机制阻止
//我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。
//在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的。
class NoCopy{
	NoCopy() = default;
	NoCopy(const NoCopy &) = delete;
	NoCopy & operator=(const NoCopy &) = delete;
	~NoCopy() = delete;
};
//与=default不同，=delete 必须出现在函数第一次声明时，编译器需要知道一个函数是杀出的，以便禁止试图使用它的时候。
//析构函数不能被删除
//我们不能删除析构函数，如果析构函数被删除，就无法销毁此类型的对象了。
//对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量。如果一个类有某个成员变量删除了析构函数，我们也不能定义该类的变量。
//注意！虽然不能定义变量，但可以动态分配这种对象，但又不能释放这些对象。

//如果一个类有成员变量不能默认构造、拷贝、销毁，则对应的合成的成员函数将被定义为删除的。
//当不可能拷贝、赋值、销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。

//对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数。
//解释：如果一个类有const成员，则它不能使用合成的拷贝构造函数。（将一个新值赋予一个const对象是不可能的）
//虽然可以将一个新值赋予一个引用成员，但这样做改变的是引用纸箱的对象的值，而不是引用本身。如果为这样的类合成拷贝赋值运算符，则赋值后，左侧运算对象仍然指向与赋值前一样的对象。
//因此对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。

//当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。



