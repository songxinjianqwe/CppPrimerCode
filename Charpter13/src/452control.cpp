/*
 * 452control.cpp
 *
 *  Created on: 2016年9月12日
 *      Author: songx
 */
//拷贝控制与资源管理

//可以定义拷贝操作，使类的行为看起来像一个值或像一个指针
//如何拷贝指针成员决定了类时具有类值行为还是类指针行为
//类的行为像一个值，意味着它应该有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。
//行为像指针的类则共享状态，当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象。

//行为像值的类
//拷贝构造函数只要将右值的指针成员变量所指向的值拷贝一份复制到左值即可。
//析构函数将释放指针指向的动态内存
//拷贝赋值运算符组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源；类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。但是这些操作
//是以正确的顺序执行的，即使是一个对象赋予它自身，也保证正确。而且，如果可能，我们编写的赋值运算符还应该是异常安全的。


HasPtr& operator=(const HasPtr & hp){
	string * newPtr = new string(*hp.ps);
	delete ps;
	ps = newPtr;
	i = hp.i;
	return *this;
}


//编写赋值运算符时，有两点需要注意：
//1.如果将一个对象赋予它自身，赋值运算符必须能正确工作。
//2.大多数赋值运算符组合了西沟函数和拷贝构造函数的工作。
//当编写一个赋值运算符时，一个好的模式是现将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。
//一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。
//上面的代码如果写成delete ps; ps = new string(*hp.ps); 就不满足第一点了。因为释放了之后就不能再去访问数据了。




