/*
 * 695namespace.cpp
 *
 *  Created on: 2016年10月3日
 *      Author: songx
 */




using namespace std;

//命名空间
//多个库将名字放置在全局命名空间中将引发命名空间污染
//命名空间为防止名字冲突提供了更加可控的机制。命名空间分隔了全局命名空间，其中每个命名空间是一个作用域。提供在某命名空间中定义库的名字，
//库的作者以及用户可以避免全局名字固有的弊端。
//命名空间的定义：
//namespace 命名空间名 。在命名空间名字后面是一系列由花括号括起来的定义和声明。
//只要能出现在全局作用域的声明就能置于命名空间中，主要包括：类，变量，函数，模板和其他命名空间
namespace cpp{
	class SalesData{/**/};
	SalesData operator+(const SalesData &,const SalesData &);
	class Query{/**/}
}//结束时无分号
//和其他名字一样，命名空间的名字也必须在定义它的作用域内保持唯一。命名空间既可以定义在全局作用域内容，也可以定义在其他命名空间中，但是不能定义在函数或类内部。

//每个命名空间都是一个作用域
//命名空间中的每个名字都必须表示该空间内的唯一实体。因为不同命名空间的作用域不同，所以在不同命名空间内可以有相同名字成员.
//定义在某个命名空间中的名字可以被命名空间内的其他成员直接访问，也可以被这些成员内掐作用域中的任何单位访问。
//位于该命名空间之外的代码则必须明确指出所用的名字属于哪个命名空间：
cpp::Query q = cpp::Query("test");
//如果其他命名空间中也提供了Query类，并希望以此替代cpp中的同名类
//addison::Query q = addison::Query("test");

//命名空间可以是不连续的
//命名空间可以定义在几个不同的地方。
namespace nsp{
//	
}
//可能是定义了一个名为nsp的新的命名空间，也可能为已经存在命名空间添加一些新成员。
//命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间。此时，命名空间的组织方式类似于我们管理自定义类和函数的方式
//命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中、
//命名空间成员的定义部分则置于另外的源文件中。

//定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型
//SalesData.h
//#include 应该出现在打开命名空间的操作之前
#include <string>
namespace cpp_primer{
	class SalesData{
		
	};
	SalesData operator+(const SalesData & ,const SalesData & );
	
}
//SalesData.cpp
#include "SalesData.h"
namesapce cpp_primer{
	//其他定义
}
//使用
//main.pp
#include "SalesData.h"
int main(){
	using cpp_primer::SalesData;
	SalesData item1,item2;//.....
}
//通常情况下，我们不把include放在命名空间内部。如果我们这么做了，隐含的意思就是把头文件中的所有的名字定义成该命名空间的成员

//定义命名空间成员
//假定作用域中存在合适的声明语句，则命名空间中的代码可以使用同一命名空间定义的名字的简写形式
#include "SalesData.h"
namespace cpp_primer{
	//命名空间中定义的成员可以直接使用名字，无需前缀
}

//也可以在命名空间定义的外部 定义该命名空间的成员。命名空间对于名字的声明必须在作用域内，同时该名字的定义需要明确指出其属的命名空间、
cpp_primer::SalesData cpp_primer::operator +(const SalesData & lhs,const SalesData & rhs){
	SalesData ret(lhs);
}
//尽管命名空间的成员可以定义在命名空间外部，但是这样的电柜必须出现在所属命名空间的外层空间中。我们可以在cpp_primer或
//全局作用域中定义SalesData::operator +，但是不能在一个不相关的作用域中定义这个运算符。

//模板特例化
//模板特例化必须定义在原始模板所属的命名空间中，只要我们在命名空间中声明了特例化，就能在命名空间外部定义它了
namespace std{
	template<> struct hash<SalesData>;
}
template <>struct std::hash<SalesData>{
	size_t operator()(const SalesData & s)const{
		return hash<string>()(s.bookNo)/*省略*/;
	}
};

//全局命名空间
//全局作用域中的名字也就是定义在全局命名空间中。全局命名空间以隐式的方式声明，并且在所有程序中都存在。
//全局作用域中定义的名字被隐式地添加到全局命名空间中。
//作用域运算符同样可以用于全局作用域的成员。
//::member
//表示全局命名空间的一个成员

//嵌套的命名空间
//嵌套的命名空间是指定义在其他命名空间中的命名空间
namespace cpp_primer{
	namespace QueryLib{
		class Query{};
	}
	namespace bookStore{
		class Quote{};
	}
}
//嵌套的命名空间同时是一个嵌套的作用域，它嵌套在外层命名空间的作用域中。嵌套的命名空间中的名字遵循的规则与往常类似：
//内层命名空间声明的名字将隐藏外层命名空间声明的同名成员。
//在嵌套的命名空间中定义的名字只在内层命名空间中有效。
//外层命名空间中的代码要想访问它必须在名字前添加限定符。
cpp_primer::QueryLib::Quote;


//内联命名空间
//内联命名空间中的名字可以被外层命名空间直接使用。我们无需在内联命名空间中的名字前添加表示该命名空间的前缀。通过外层命名空间的名字就可以直接访问它。
//定义内联命名空间的方式是在关键字namespace前添加关键字inline
inline namespace FifthEd{
	//
}
namespace Fifth{
	class QueryBase{};
}

//关键字必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写inline也可以不写
//我们可以把本书当前版本的所有代码放在一个内联命名空间里，之前版本的代码放在一个非内联命名空间中
namespace FourthEd{
	class ItemBase{};
	class QueryBase{};
}
//命名空间cpp_primer将同时使用这两个命名空间
//我们可以将命名空间cpp_primer定义成如下形式：
namespace cpp_primer{
	#include "FifthEd.h"
	#include "FourthEd.h"
}
//因为FifthEd是内联的，所以形如cpp_primer::的代码可以直接获得FifthEd的成员。如果我们使用早期版本的代码。则必须向其他嵌套的命名空间一样
//加上完整的外层命名空间名字，比如cpp_primer::FourthEd::QueryBase;

//未命名的命名空间
//未命名的命名空间是指关键字namespace后紧跟花括号括起来的一系列声明语句。未命名的命名空间中定义的变量拥有静态声明周期
//它们在第一次时候时创建，并且直到程序结束才销毁、
//一个未命名的命名空间可以在某个给定的文件之内不连续，但是不能跨越多个文件，每个文件定义自己的未命名的命名空间、
//如果两个文件都含有未命名的命名空间，则这两个空间无关。在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的是不同实体。
//如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体。
//定义在未命名的命名空间中的名字可以直接使用。同样，我们也不能对未命名的命名空间中的成员使用作用域运算符
//未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同
int i ;
namespace {
	int i;
}
//i = 10;//error 具有二义性
//一个未命名的命名空间也能嵌套在其他命名空间当中。此时，未命名的命名空间中的成员可以通过外层命名空间的名字来访问
namespace local{
	namespace{
		int i;
	}
}
local::i = 42;
//未命名的命名空间取代文件中的静态声明
//在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命名的命名空间

//*********************************************************************************************

//命名空间的别名
//我们可以为命名空间的名字设定一个短的同义词
namespace primer = cpp_primer;
//不能在命名空间还没有开始定义前就声明别名，否则将产生错误
//命名空间中的别名也可以指向一个嵌套的命名空间
namespace QLib = cpp_primer::QueryLib;
//一个命名空间可以有多个别名

//using声明
//using声明（declaration）一次只引入一个命名空间的一个成员
//一条using声明可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中。
//在类的作用域中，这些的声明语句只能指向基类成员

//using指示（directive）
//我们可以使用命名空间名字的简写形式。缺点是我们无法控制哪些名字是可见的，因为所有名字都是可见的。
//using指示可以出现在全局作用域、局部作用域和命名空间作用域中，但是不能出现在类作用域中。


namespace blip{
	int ii = 16,jj = 15,kk = 23;
}
int jj = 0;
void test3(){
	using namespace blip;
	++ii;
//	++jj;//error
	++::jj;//ok
	++blip::jj;//ok
}
//当命名空间被注入到它的外层作用域会后，有可能该命名空间中定义的名字会与其外层作用域中的成员冲突。相使用冲突的名字，我们就必须明确指出名字的版本
//头文件如果在其顶层作用域中含有using指示或using声明，则会将名字注入到所有包含了该头文件的文件中。
//通常情况下，头文件应该只负责定义接口部分的名字，而不定义实现部分的名字。
//头文件最多只能在它的函数或命名空间中使用using指示或using声明。

//**********************************************************************************

//类、命名空间与作用域

//对命名空间内部名字的查找遵循常规的查找规则：由内向外依次查找每个外层作用域。
//外层作用域也可能是一个多火哥嵌套的命名空间，直到最外层的全局命名空间查找过程终止。
//只有位于开放的块中且在使用点之前声明的名字才被考虑
namespace A{
	int i ;
	namespace B{
		int i;
		int j;
		int f1(){
			int j;
			return i;
		}
	}
	
	int f2(){
		return j;
	}
	int j = i;
}


namespace C{
	int i;
	int k;
	class Clazz{
	public:
		Clazz():i(0),j(0){}
		int f1(){
			return k;//这里的k相当于C::k
		}
		int f2(){
			return h;//error h定义在下面
		}
		int f3();
	private:
		int i;//隐藏了外层的i
		int j;
	};
	int h = i;//用C::i初始化
}
int C::Clazz::f3(){
	return h;
}
//对于命名空间中名字的隐藏规则有一个重要的例外，它使得我们可以直接访问输出运算符
//这里例外是：当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会有查找实参类所属的命名空间。
//这一例外对于传递类的引用或指针的调用同样有效。

//查找规则的这个例外允许概念上作为类接口的一部分的非成员函数无需单独的using声明就能被程序使用。
void t(){
	string s;
	cin>>s;
}
//move和forward调用时希望加上std::，目的是避免和自己定义的名字冲突

//当类声明一个友元时，该友元声明并没有使得友元本身可见
//一个另外的卫生么的类或函数如果第一次出现在友元声明中，则我们认为它是最近的外层命名空间的成员。
namespace D{
	class E{
		friend void f2();
		friend void f(const E&);
	};
}
//此时f和f2都是命名空间D的成员。即使f不存在其他声明，我们也能通过实参相关的查找规则调用f
void test7(){
	D::E obj;
	f(obj);//通过在D::E中的友元声明找到D::f
//	f2();//error
}
//因为f接受一个类类型的实参，而且f在E所属的命名空间进行了隐式的声明，所以f能被找到。
//因为f2没有形参，所以它无法被找到。

//*********************************************************************
//重载与命名空间

//对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中仅。这条规则对于我们如何确定候选函数集也有影响。
//我们将在每个实参类及基类所属的命名空间中搜寻候选函数，在这些命名空间中所有与被调用函数同名的函数都将被添加到候选集中
//即使其中莫木屑函数在调用语句处不可见
namespace NS{
	class Quote{};
	void display(const Quote &){}
}
class BulkItem :public NS::Quote{};
void test8(){
	BulkItem book1;
	display(book1);
	
}
//重载与using声明
//using声明 声明的是一个名字而非一个特定的函数
//using NS::print(int);   //error
//using NS::printf;       //error
//当我们为函数写using声明时，该函数的所有版本都被引入到当前作用域中。
//一个using声明引入的函数将重载该声明语句所属作用域中已有的同名函数。

//重载与using指示
//using指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命名空间所属作用域的函数同名，则命名空间的函数将被添加到重载集合中。

//与using声明不同的是，using指令引入一个与已有函数形参列表完全相同的函数并不会产生错误。
//只有我们指明调用的是命名空间中的函数还是当前作用域的版本即可
//










