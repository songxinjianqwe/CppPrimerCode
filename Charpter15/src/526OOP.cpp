/*
 * 526OOP.cpp
 *
 *  Created on: 2016年9月17日
 *      Author: songx
 */

#include <BulkQuote.h>
#include <iostream>
#include <Quote.h>
extern double printTotal(ostream & os,const Quote & item,size_t n);
using namespace std;
//OOP的核心是数据抽象、继承和动态绑定
//虚函数：基类希望它的派生类各自定义适合自身的版本，在基类中将这些函数生命诚虚函数，在这样的函数之前加上virtual关键字
//派生类必须通过类派生列表明确指出它是从哪个/哪些基类继承而来。
//类派生列表：首先是一个冒号，索面紧跟着以逗号分隔的基类列表，其中每个基类前面有访问控制符。
//派生类必须在其内部对所有重新定义的虚函数进行声明，派生类可以在这样的函数之前加上virtual关键字，但不是必需的。
//动态绑定：同样的代码来处理基类和派生类
//基类的指针或引用可以指向基类及其所有的派生类

//基类通常都应该定义一个虚西沟函数，即使该函数不执行任何实际操作
//基类通过在其成员函数的声明语句之前加上virtual关键字使得该函数执行动态绑定。
//任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。
//如果基类把一个函数声明成虚函数，那么该函数在派生类中隐式地也是虚函数。
//成员函数如果没有被定义为虚函数，那么其解析过程发生在编译时而非运行时。

//派生类能访问基类的公有成员，而不能访问私有成员。
//还有一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们使用protected来说明这样的成员。

//类派生列表的基类之前可以有以下三种访问说明符中的一个：public、private、protected
//这个访问控制符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见（构成接口）
//如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。

//派生类经常覆盖它继承的虚函数，但不是必须的。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，
//派生类会直接继承其在基类中的版本。
//Java中父类的方法就类似于C++中的虚函数，可以重写也可以不重写，但是父类中的抽象方法是子类必须要去重写的。

//派生类可以在它覆盖的函数前使用virtual关键字，但不是必须的。派生类可以显式地注明它使用某个成员函数覆盖了它
//继承的虚函数。具体方法是在形参列表之后、或const（const成员函数）之后、或在&（左值引用成员函数）之后添加override关键字

//派生类到基类的类型转换
void test1() {
	Quote item;
	BulkQuote bulk;
	Quote * p = &item;
	p = &bulk;
	Quote & r = bulk;
}
//派生类构造函数：派生类必须使用基类的构造函数来初始化它的基类部分
//除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化，如果想使用其他的基类构造函数，我们需要以类名
//加圆括号内的实参列表的形式为构造函数提供初始值。这些实参将帮助编译器决定到底应该选用哪个构造函数来初始化派生类对象的基类部分。

//首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的部分
//派生类可以访问基类的公有成员和受保护成员

//每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的接力部分也是如此。
//派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。

//继承与静态成员
//静态尘缘遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，
//则我们既能通过基类使用它，也能通过派生类使用它。


//派生类的声明：
//派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生列表。
//class BulkQuote

//如果我们要将某个类作为基类，则该类必须已经定义而非仅仅声明：
//还有一层隐含的意思：一个类不能派生它自己

//防止一个类被继承，在类名后跟一个关键字final 
class NoDerived final{
	//.....
};
void test2(){
	Quote q("123-10000-123",23.99);
	BulkQuote q2("123-10000-123",23.99,10,0.2);
	printTotal(cout,q,20);
	printTotal(cout,q2,20);
}



//派生类中重写的虚函数，前面可以加上virtual，后面可以加上overide，但是都不是必须的。
//但是在实现的时候，都不能加。


//类型转换与继承
//和内置指针一样，智能指针类也支持派生类向基类的类型转换，我们可以将一个派生类对象的指针存储在一个基类的智能指针内。

//静态类型与动态类型
//当我们使用存在继承关系的类时，必须将一个变量或其他表达式的静态类型和该表达式表示对象的动态类型区分开来。
//表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。
//动态类型直到运行时才可知。
//如果表达式不是指针或引用，那么它的动态类型永远与静态类型一致。


//派生类可以视为基类，但基类不可视为派生类
//一个特殊情况是：即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类到派生类的转换
void test3(){
	BulkQuote bulk;
	Quote * pitem = & bulk;//ok
//	BulkQuote * pbulk = pitem;//error
}

//具有继承关系的类之间发生的类型转换，有3点非常重要：
//1.从派生类向基类的类型转换只对指针或引用有效
//2.基类向派生类不存在隐式类型转换
//3.派生类向基类的类型转换也可能会由于访问受限而变得不可行。


