/*
 * virtualFunction.cpp
 *
 *  Created on: 2016年9月20日
 *      Author: songx
 */


#include <iostream>
using namespace std;

//对虚函数的调用在运行时才被解析
//当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到
//指针或引用上的对象的动态类型相匹配的那个。
//动态绑定只有当我们通过指针或引用调用虚函数时才会发生。
//当我们通过一个具有普通类型（非指针、引用）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。

//引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在。

//对非虚函数的调用在编译时进行绑定。通过对象进行的函数调用也在编译时绑定。

//当我们在派生类覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质
//但这不是必须的。因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数
//一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。
//同样，派生类中虚函数的返回类型也必须与基类函数匹配。这条规则有一个例外，就是当类的虚函数返回类型是本身的指针或引用时
//上述规则无效


//派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的。
//但这并没有覆盖掉基类中的版本。
//使用override关键字来说明派生类中的虚函数。好处是使得程序员的意图更加清晰的同时让编译器可以为我们发生一些错误。
//后者在编程实践中显得更加重要。
//如果我们使用override标记了某个函数，而该函数并没有覆盖已存在的虚函数，那么编译器将报错。

//我们可以还能将某个函数指定为final。如果我们已经把函数定义为final了，则之后任何尝试覆盖该函数的操作都将引发错误。
//final和override说明符出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后。

//虚函数也可以拥有默认实参，如果某次函数调用使用了默认实参，那么该实参值由本次调用的静态类型决定。
//如果我们通过基类的指针或引用调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是这样。

//回避虚函数机制
//某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个调用版本。使用作用域运算符可以实现这一目的。
//double d = baseP->Quote::netPrice(42);
//强制调用Quote的netPrice函数，而不管baseP实际指向的对象类型到底是什么。该调用将在编译时完成解析。
//通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数机制
//通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时

//如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本的自身调用，从而导致无限循环



