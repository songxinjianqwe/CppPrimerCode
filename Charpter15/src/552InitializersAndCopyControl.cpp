/*
 * 552InitializersAndCopyControl.cpp
 *
 *  Created on: 2016年9月23日
 *      Author: songx
 */
#include <iostream>
using namespace std;


//虚析构函数
//为了避免指针的静态类型与被删除对象的动态类型不符的情况。
//我们通过在基类中将析构函数定义为虚函数以确保执行正确的析构函数版本

//只要基类的析构函数是虚函数，就能确保当我们delete基类指针时运行正确的析构函数版本
//如果基类的析构函数不是虚函数，那么delete一个指向派生类对象的基类指针将产生未定义的行为
//如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作。积累的虚构函数并不遵循上述准则。
//一个基类总是需要析构函数，而且它能将析构函数设定为虚函数

//虚析构函数将阻止 合成移动操作
//如果一个类定义了析构函数，即使它通过=default形式使用了合成的版本，编译器也不会为这个类合成移动操作

/////////////////////////////////////////////////////////////////////////////////
//合成拷贝控制成员与继承
//合成的拷贝控制成员对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中
//对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁。

//比如合成的BulkQuote默认构造函数运行DiscQuote的默认构造函数，后者又运行Quote的默认构造函数。
//无论基类成员是合成的版本还是自定义版本都没有太大影响，唯一的要求是相应的成员都应该可访问，而且不是一个被删除的函数
//合成析构函数
//基类通过将其虚析构函数定义成=default来使用，派生类隐式地使用
//对于派生类的析构函数而言，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类。
//该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。

//Quote因为定义了析构函数而不能拥有合成的移动操作（但可以自定义移动操作），因此当我们移动Quote对象时实际使用的是合成的拷贝操作。

/////////////////////////////////////////////////////////////////////////////////

//基类和派生类可以将其合成的拷贝控制成员定义为删除的函数
//某些定义基类的方式也有可能导致有的派生类成员称为被删除的函数

//如果基类的合成的拷贝控制成员(默认、移动、拷贝、析构)是被删除的函数或不可访问，则派生类中对应的成员是被删除的
//如果基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认构造函数和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分

//在实际编程中，如果在基类中没有默认、拷贝、移动构造函数，那么一般情况下派生类也不会定义相关的操作

/////////////////////////////////////////////////////////////////////////////////

//移动操作与继承
//在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作
//因为基类缺少移动操作会足而知派生类拥有自己的合成移动草，所以当确实需要移动操作时首先应该在基类中定义


class Quotee{
public:
	Quotee() = default;
	Quotee(const Quotee &) = default;
	Quotee(Quotee &&) = default;
	Quotee & operator=(const Quotee &) = default;
	Quotee & operator=(Quotee &&) = default;
	virtual ~Quotee() = default;
};
/////////////////////////////////////////////////////////////////////////////////

//派生类的拷贝控制成员
//派生类构造函数在其初始化阶段不仅要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。
//因此派生类的拷贝和移动构造函数在拷贝和移动自己的成员外，也要拷贝和移动基类部分的陈冠。（赋值运算符也是如此）
//与构造函数与赋值运算符不同，析构函数只负责销毁派生类自己分配的资源，派生类对象的基类部分也是自动销毁的。
//只有销毁是自动的，其他都不是自动的

//定义派生类的拷贝或移动构造函数
class Base5{
public:
	Base5(const Base5 &) = default; 
	Base5(Base5 &&) = default;
	Base5 & operator=(const Base5 &) = default;
};
class Deri:public Base5{
	Deri(const Deri & d):Base5(d)/*Deri自己的成员*/{}
	Deri(Deri && d):Base5(move(d))/*Deri自己的成员*/{}
	Deri& operator=(const Deri & d){
		Base5::operator=(d);
		//按照以前的方式为派生类的成员赋值
		//处理自赋值和释放资源情况
		return *this;
	}
};
//Base5(d)会匹配Base5的拷贝构造函数。Deri类的对象d将被绑定到该构造函数的Base5&形参上。
//Base5的拷贝构造函数负责将d的基类部分拷贝给要创建的对象
//如果没有写 Base5(d)  ，那Base5的默认构造函数将被用来初始化Deri对象的基类部分

//在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝、移动基类部分，那么必须在派生类的拷贝、移动构造函数
//列表中显式地使用基类的拷贝或移动构造函数

//派生类赋值运算符
//和拷贝、移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值
//见上

//首先显式地调用基类赋值运算符，令其为派生类对象的基类部分赋值。基类的运算符应该可以正确处理自赋值的问题。
//如果赋值命令是正确的，则基类运算符将释放掉其左侧运算对象的基类部分的旧值，然后利用rhs为其赋一个新值。随后我们继续进行其他为派生类成员赋值的工作
//注意，无论基类的拷贝控制成员是自定义版本还是合成版本，派生类的对应操作都能使用它们。


//派生类析构函数
//对象的基类部分是隐式销毁的，派生类析构函数只负责销毁由派生类自己分配的资源
//对象销毁的顺序正好与其创建的顺序相反，派生类析构函数首先执行，然后是基类的析构函数，以此类推。

//在构造函数和析构函数中调用虚函数
//当构造派生类的对象时，先构造派生类中的基类部分
//当基类构造函数调用虚函数的派生类版本时，这个虚函数可能会访问派生类的成员。而此时派生类的自己的成员尚未初始化
//NOte:如果构造函数或析构函数调用了某个虚函数，那么我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本








