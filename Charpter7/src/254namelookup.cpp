#include <iostream>
using namespace std;
//名字查找（变量名，函数名）
//首先，在名字所在的块中寻找其声明，只考虑在名字的使用之前出现的声明
//如果没找到，继续查找外层作用域
//如果最终没有找到，则报错

//对于定义在类内部的成员函数而言
//1、编译成员（包括成员变量和成员函数）的声明
//2、直到类全部可见后才编译函数体
//编译器处理完类中的全部声明后才会处理成员函数的定义
//上面的只适用于成员函数中的名字
//对于声明中使用的名字，包括返回类型、参数列表中的名字，都必须在使用前可见
//如果某个成员的声明使用了类中尚未出现的名字，那么编译器将会在定义该类的作用域中继续查找
//详细如下：
//1、在成员函数内部查找该名字的声明。只有在函数使用之前出现的声明才被考虑
//2、如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑
//3、如果类内没有找到该名字的声明，在成员函数定义之前的作用域内继续查找
int height = 21;
class Cat {
public:
	void print(int height) {
		//这里的height参数覆盖了同名的成员变量（不推荐这样做，参数的名字应该与成员变量区分开）
		//但是如果相同，也可以使用this或::来访问内部成员变量
		cout << Cat::height << endl;
		cout << this->height << endl;
		//在类内部也可以访问同名的外部的全局变量，使用作用域运算符
		cout << ::height << endl;
	}
	//建议写法
	/*void print(int ht) {

	}*/
	void setHeight(int);
	

private:
	int height = 0;
	int weight = 0;
};
//当成员函数定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明。
int verify(int val) {
	return val;
}
void Cat::setHeight(int var) {
	height = verify(var);
}



//*********************************************************************************************************************************************
//内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。
//然而在类中，如果成员使用了外层作用域中的某个名字，并且该名字代表一种类型，则类不能在之后重新定义该名字

//注意:类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后

typedef double Money;
class Account {
public :
	Money balance() {
		return bal;
	}
private:
	typedef double Money;//error
	Money bal = 0;
};
int main(void) {
	Account acc;
	cout << acc.balance() << endl;
	return 0;
}
